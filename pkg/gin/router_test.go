package gin

import (
	"testing"

	"github.com/DougTea/go-common/pkg/web"
)

const golden = `// Code generated by "rest-go-generator"; DO NOT EDIT.

package test

import (
	"net/http"

	"github.com/DougTea/go-common/pkg/web"
	"github.com/gin-gonic/gin"
)

type TestResource1Service interface{
	Get(TestParam1)(TestResult1,error)
	Post(TestParam2)error
	Post1()(TestResult3,error)
}

type TestResource1Controller struct{
	TestResource1Service TestResource1Service
	Routers []*web.Router
}

func NewTestResource1Controller(svc TestResource1Service)*TestResource1Controller{
	return TestResource1Controller{
		TestResource1Service: svc,
		Routers: []*web.Router{
			newGetTestResource1Router(svc),
			newPostTestResource1Router(svc),
			newPostTestResource1Router(svc),
		}
	}
}

// get TestResource1 godoc
// @Summary GET TestResource1
// @Description GET TestResource1
// @Accept  json
// @Produce  json
// @Param TestParam1 query TestParam1 true "TestParam1 as parameters encapsulation"
// @Success 200 {object} TestResult1
// @Failure default {object} web.ErrorMessage
// @Router /test1 [GET]
func newGetTestResource1Router(svc TestResource1Service)*web.Router{
	return &web.Router{
		Method: web.MethodGet
		Path: /test1
		Handler: func(c *gin.Context){
			p := new(TestParam1)
			err := c.Bind(p)
			if err!=nil{
				c.Error(err)
				return
			}
			r,err := svc.Get(p)
			if err!=nil{
				c.Error(err)
			}else{
				c.Json(200,r)
			}
		}
	}
}

// post TestResource1 godoc
// @Summary POST TestResource1
// @Description POST TestResource1
// @Accept  json
// @Produce  json
// @Param TestParam2 body TestParam2 true "TestParam2 as parameters encapsulation"
// @Success 201 {object} nil
// @Failure default {object} web.ErrorMessage
// @Router /test1 [POST]
func newPostTestResource1Router(svc TestResource1Service)*web.Router{
	return &web.Router{
		Method: web.MethodPost
		Path: /test1
		Handler: func(c *gin.Context){
			p := new(TestParam2)
			err := c.Bind(p)
			if err!=nil{
				c.Error(err)
				return
			}
			err = svc.Post(p)
			if err!=nil{
				c.Error(err)
			}else{
				c.Json(201,nil)
			}
		}
	}
}

// post1 TestResource1 godoc
// @Summary POST TestResource1
// @Description POST TestResource1
// @Accept  json
// @Produce  json
// @Success 201 {object} TestResult3
// @Failure default {object} web.ErrorMessage
// @Router /test1 [POST]
func newPostTestResource1Router(svc TestResource1Service)*web.Router{
	return &web.Router{
		Method: web.MethodPost
		Path: /test1
		Handler: func(c *gin.Context){
			r,err := svc.Post()
			if err!=nil{
				c.Error(err)
			}else{
				c.Json(201,r)
			}
		}
	}
}

type TestResource2Service interface{
	Get(TestParam3)(TestResult3,error)
}

type TestResource2Controller struct{
	TestResource2Service TestResource2Service
	Routers []*web.Router
}

func NewTestResource2Controller(svc TestResource2Service)*TestResource2Controller{
	return TestResource2Controller{
		TestResource2Service: svc,
		Routers: []*web.Router{
			newGetTestResource2Router(svc),
		}
	}
}

// get TestResource2 godoc
// @Summary GET TestResource2
// @Description GET TestResource2
// @Accept  json
// @Produce  json
// @Param TestParam3 query TestParam3 true "TestParam3 as parameters encapsulation"
// @Success 200 {object} TestResult3
// @Failure default {object} web.ErrorMessage
// @Router /test2 [GET]
func newGetTestResource2Router(svc TestResource2Service)*web.Router{
	return &web.Router{
		Method: web.MethodGet
		Path: /test2
		Handler: func(c *gin.Context){
			p := new(TestParam3)
			err := c.Bind(p)
			if err!=nil{
				c.Error(err)
				return
			}
			r,err := svc.Get(p)
			if err!=nil{
				c.Error(err)
			}else{
				c.Json(200,r)
			}
		}
	}
}`

func TestGenerateRouter(t *testing.T) {
	// g := NewRestGinControllerGenerator(&Controller{
	// 	Package: "test",
	// 	Routes: []*Route{
	// 		{
	// 		},
	// 		{
	// 		},
	// 	},
	// })
	// x := g.Generate()
	// fmt.Println("Whole generated file:")
	// fmt.Println(x)
	// diffs := diff.Do(golden, x)
	// hasDiff := false
	// if len(diffs) > 1 || len(diffs) == 1 && diffs[0].Type != diffmatchpatch.DiffEqual {
	// 	hasDiff = true
	// }
	// if hasDiff {
	// 	fmt.Println("---------------------------------------------------------------")
	// 	for _, d := range diffs {
	// 		fmt.Println(d)
	// 		if d.Type != diffmatchpatch.DiffEqual {
	// 			hasDiff = true
	// 		}
	// 	}
	// 	t.Fatal(len(diffs), "diffs!")
	// }
}

func TestHttpMethod_CamelString(t *testing.T) {
	tests := []struct {
		name string
		h    HttpMethod
		want string
	}{
		{
			name: "GET",
			h:    HttpMethod(web.MethodGet),
			want: "Get",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.h.CamelString(); got != tt.want {
				t.Errorf("HttpMethod.CamelString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHttpMethod_LowerString(t *testing.T) {
	tests := []struct {
		name string
		h    HttpMethod
		want string
	}{
		{
			name: "GET",
			h:    HttpMethod(web.MethodGet),
			want: "get",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.h.LowerString(); got != tt.want {
				t.Errorf("HttpMethod.LowerString() = %v, want %v", got, tt.want)
			}
		})
	}
}
