package gin

import (
	"log"
	"strings"
	"text/template"

	"devgit.westwell-lab.info/jiaqing.kuang/common/pkg/web"
)

const RouterTpl = `// Code generated by "rest-go-generator"; DO NOT EDIT.

{{ $package := .Package -}}
package {{ $package }}

import (
	"net/http"

	"devgit.westwell-lab.info/jiaqing.kuang/common/pkg/web"
	"github.com/gin-gonic/gin"
)

{{- range .Resources -}}
{{- $upperResource:= .Name | firstUpper }}
{{- $path:= .Path }}

type {{ $upperResource }}Service interface{
	{{- range .Actions -}}
	{{- $camelMethodName := .Method.CamelString }}
	{{- if .Result }}
	{{ $camelMethodName }}({{ .Param }})({{ .Result }},error)
	{{- else -}}
	{{ $camelMethodName }}({{ .Param }})error
	{{- end -}}
	{{- end }}
}

type {{ $upperResource }}Controller struct{
	{{ $upperResource }}Service {{ $upperResource }}Service
	Routers []*web.Router
}

func New{{ $upperResource }}Controller(svc {{ $upperResource }}Service)*{{ $upperResource }}Controller{
	return {{ $upperResource }}Controller{
		{{ $upperResource }}Service: svc,
		Routers: []*web.Router{
		{{- range .Actions }}
		{{- $camelMethodName := .Method.CamelString }}
			new{{ $camelMethodName }}{{ $upperResource }}Router(svc),
		{{- end }}
		}
	}
}

{{- range .Actions -}}
{{- $camelMethodName := .Method.CamelString -}}
{{- $code := .Method | codeOfMethod }}

// {{ $camelMethodName }}{{ $upperResource }} godoc
// @Summary {{ .Method }} {{ $upperResource }}
// @Description {{ .Method }} {{ $upperResource }}
// @Accept  json
// @Produce  json
{{- if .Param }}
// @Param {{ .Param }} {{ if eq .Method "GET" -}}query{{- else -}}body{{- end }} {{ .Param }} true "{{ .Param }} as parameters encapsulation"
{{- end }}
// @Success {{ $code }} {object} {{ if .Result -}}{{ .Result }}{{- else -}}nil{{- end }}
// @Failure default {object} web.ErrorMessage
// @Router {{ $path }} [{{ .Method }}]
func new{{ $camelMethodName }}{{ $upperResource }}Router(svc {{ $upperResource }}Service)*web.Router{
	return &web.Router{
		Method: web.Method{{ $camelMethodName }}
		Path: {{ $path }}
		Handler: func(c *gin.Context){
			{{- if .Param }}
			p := new({{ .Param }})
			err := c.Bind(p)
			if err!=nil{
				c.Error(err)
				return
			}
			{{- end -}}
			{{- if and .Param .Result }}
			r,err := svc.{{ $camelMethodName }}(p)
			{{- else if .Param }}
			err = svc.{{ $camelMethodName }}(p)
			{{- else if .Result }}
			r,err := svc.{{ $camelMethodName }}()
			{{- else }}
			err = svc.{{ $camelMethodName }}()
			{{- end }}
			if err!=nil{
				c.Error(err)
			}else{
				{{- if .Result }}
				c.Json({{ $code }},r)
				{{- else }}
				c.Json({{ $code }},nil)
				{{- end }}
			}
		}
	}
}
{{- end -}}
{{- end -}}
`

type RestRouteGenerator struct {
	Route    *Route
	template *template.Template
}

func NewRestRouteGenerator(r *Route) *RestRouteGenerator {
	tpl, err := template.New("route").Funcs(template.FuncMap{
		"firstLower": ToFirstLowerString,
		"firstUpper": ToFirstUpperString,
		"codeOfMethod": func(method HttpMethod) int {
			if web.HttpMethod(method) == web.MethodGet {
				return 200
			} else if web.HttpMethod(method) == web.MethodPost {
				return 201
			}
			return 202
		},
	}).Parse(RouterTpl)
	if err != nil {
		log.Fatal(err)
	}
	return &RestRouteGenerator{
		Route:    r,
		template: tpl,
	}
}

func (r *RestRouteGenerator) Generate() string {
	b := new(strings.Builder)
	err := r.template.Execute(b, r.Route)
	if err != nil {
		log.Fatal(err)
	}
	return b.String()
}

type Route struct {
	Package   string      `json:"package"`
	Resources []*Resource `json:"resources"`
}

type Resource struct {
	Name    string    `json:"name"`
	Path    string    `json:"path"`
	Actions []*Action `json:"actions"`
}

type Action struct {
	Method HttpMethod `json:"method"`
	Param  string     `json:"param"`
	Result string     `json:"result"`
}

type HttpMethod web.HttpMethod

func (h HttpMethod) CamelString() string {
	return ToFirstUpperString(h.LowerString())
}

func (h HttpMethod) LowerString() string {
	return strings.ToLower(string(h))
}

func ToFirstLowerString(str string) string {
	b := []byte(str)
	if b[0] >= 'A' && b[0] <= 'Z' {
		b[0] = 'a' + (b[0] - 'A')
	}
	return string(b)
}

func ToFirstUpperString(str string) string {
	b := []byte(str)
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] = 'A' + (b[0] - 'a')
	}
	return string(b)
}
